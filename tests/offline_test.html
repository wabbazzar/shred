<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Offline PWA Test - 6Week Shred</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #121212;
            color: #FFFFFF;
            padding: 20px;
            line-height: 1.6;
        }

        .test-header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #FF6B00, #FF8533);
            border-radius: 12px;
        }

        .test-header h1 {
            font-size: 24px;
            margin-bottom: 8px;
        }

        .test-header p {
            opacity: 0.9;
            font-size: 14px;
        }

        .test-section {
            margin-bottom: 30px;
            padding: 20px;
            background: #1E1E1E;
            border-radius: 12px;
            border: 1px solid #333;
        }

        .section-title {
            color: #FF6B00;
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .section-description {
            color: #AAA;
            font-size: 14px;
            margin-bottom: 20px;
            line-height: 1.4;
        }

        /* Status Indicators */
        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .status-card {
            padding: 16px;
            background: #2A2A2A;
            border-radius: 8px;
            border: 2px solid #444;
            transition: all 0.2s ease;
        }

        .status-card.online {
            border-color: #00C851;
            background: rgba(0, 200, 81, 0.1);
        }

        .status-card.offline {
            border-color: #FF6B00;
            background: rgba(255, 107, 0, 0.1);
        }

        .status-card.error {
            border-color: #FF4444;
            background: rgba(255, 68, 68, 0.1);
        }

        .status-title {
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-value {
            font-size: 14px;
            color: #AAA;
        }

        .status-icon {
            font-size: 18px;
        }

        /* Action Buttons */
        .action-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 20px 0;
        }

        .action-btn {
            padding: 10px 16px;
            background: #FF6B00;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
            min-height: 44px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .action-btn:hover {
            background: #FF8533;
        }

        .action-btn:disabled {
            background: #444;
            color: #888;
            cursor: not-allowed;
        }

        .action-btn.secondary {
            background: transparent;
            border: 1px solid #FF6B00;
            color: #FF6B00;
        }

        .action-btn.secondary:hover {
            background: rgba(255, 107, 0, 0.1);
        }

        /* Storage Test */
        .storage-test {
            background: #2A2A2A;
            border-radius: 8px;
            padding: 16px;
            margin: 15px 0;
        }

        .storage-input {
            width: 100%;
            padding: 10px;
            background: #1E1E1E;
            border: 1px solid #444;
            border-radius: 6px;
            color: white;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .storage-input:focus {
            outline: none;
            border-color: #FF6B00;
        }

        .storage-display {
            background: #121212;
            padding: 12px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 12px;
            max-height: 120px;
            overflow-y: auto;
            border: 1px solid #333;
        }

        /* Cache Status */
        .cache-list {
            list-style: none;
            margin: 15px 0;
        }

        .cache-item {
            padding: 8px 12px;
            background: #2A2A2A;
            border-radius: 6px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }

        .cache-item.cached {
            border-left: 4px solid #00C851;
        }

        .cache-item.failed {
            border-left: 4px solid #FF4444;
        }

        .cache-item.pending {
            border-left: 4px solid #FF6B00;
        }

        .cache-status {
            font-weight: 600;
            text-transform: uppercase;
            font-size: 10px;
        }

        /* Connection Simulator */
        .connection-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .connection-btn {
            padding: 8px 12px;
            background: #2A2A2A;
            border: 2px solid #444;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            text-align: center;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .connection-btn.active {
            border-color: #FF6B00;
            background: rgba(255, 107, 0, 0.1);
        }

        .connection-btn:hover {
            border-color: #666;
        }

        /* Test Results */
        .test-results {
            background: #0D1117;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
        }

        .result-pass { color: #00C851; }
        .result-fail { color: #FF4444; }
        .result-info { color: #FF6B00; }
        .result-warning { color: #FFA500; }

        /* Manifest Validator */
        .manifest-check {
            display: grid;
            grid-template-columns: auto 1fr auto;
            gap: 12px;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #333;
        }

        .manifest-check:last-child {
            border-bottom: none;
        }

        .check-icon {
            font-size: 16px;
        }

        .check-icon.pass { color: #00C851; }
        .check-icon.fail { color: #FF4444; }
        .check-icon.warning { color: #FF6B00; }

        .check-description {
            font-size: 14px;
        }

        .check-value {
            font-family: monospace;
            font-size: 11px;
            color: #AAA;
            text-align: right;
        }

        /* Network Status */
        .network-status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
            border: 2px solid #444;
            z-index: 1000;
            min-width: 150px;
        }

        .network-status.online {
            border-color: #00C851;
        }

        .network-status.offline {
            border-color: #FF6B00;
        }

        .network-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }

        .network-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #00C851;
            animation: pulse 2s infinite;
        }

        .network-dot.offline {
            background: #FF6B00;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Install Prompt */
        .install-prompt {
            background: linear-gradient(135deg, #FF6B00, #FF8533);
            border-radius: 8px;
            padding: 16px;
            margin: 15px 0;
            text-align: center;
            display: none;
        }

        .install-prompt.show {
            display: block;
        }

        .install-prompt h3 {
            margin-bottom: 8px;
        }

        .install-prompt p {
            font-size: 14px;
            opacity: 0.9;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <div class="network-status" id="networkStatus">
        <div class="network-indicator">
            <div class="network-dot" id="networkDot"></div>
            <span id="networkText">Checking...</span>
        </div>
        <div style="font-size: 10px; color: #AAA;" id="networkDetails">Initializing...</div>
    </div>

    <div class="test-header">
        <h1>üì∂ Offline PWA Test Suite</h1>
        <p>Comprehensive testing for service worker, caching, and offline functionality</p>
    </div>

    <div class="test-section">
        <div class="section-title">
            üîß Service Worker Status
        </div>
        <div class="section-description">
            Monitor service worker registration, installation, and activation status.
        </div>
        
        <div class="status-grid">
            <div class="status-card" id="swRegistration">
                <div class="status-title">
                    <span class="status-icon">üìã</span>
                    Registration
                </div>
                <div class="status-value" id="swRegStatus">Checking...</div>
            </div>
            
            <div class="status-card" id="swInstallation">
                <div class="status-title">
                    <span class="status-icon">‚öôÔ∏è</span>
                    Installation
                </div>
                <div class="status-value" id="swInstallStatus">Waiting...</div>
            </div>
            
            <div class="status-card" id="swActivation">
                <div class="status-title">
                    <span class="status-icon">‚úÖ</span>
                    Activation
                </div>
                <div class="status-value" id="swActiveStatus">Waiting...</div>
            </div>
            
            <div class="status-card" id="swUpdate">
                <div class="status-title">
                    <span class="status-icon">üîÑ</span>
                    Updates
                </div>
                <div class="status-value" id="swUpdateStatus">None available</div>
            </div>
        </div>
        
        <div class="action-buttons">
            <button class="action-btn" onclick="registerServiceWorker()">
                üîÑ Register SW
            </button>
            <button class="action-btn" onclick="unregisterServiceWorker()">
                ‚ùå Unregister SW
            </button>
            <button class="action-btn secondary" onclick="checkForUpdates()">
                üîç Check Updates
            </button>
        </div>
    </div>

    <div class="test-section">
        <div class="section-title">
            üíæ Cache Management
        </div>
        <div class="section-description">
            Test cache strategies and verify critical resources are cached for offline use.
        </div>
        
        <ul class="cache-list" id="cacheList">
            <li class="cache-item pending">
                <span>Loading cache status...</span>
                <span class="cache-status">Checking</span>
            </li>
        </ul>
        
        <div class="action-buttons">
            <button class="action-btn" onclick="populateCache()">
                üì¶ Populate Cache
            </button>
            <button class="action-btn" onclick="clearCache()">
                üóëÔ∏è Clear Cache
            </button>
            <button class="action-btn secondary" onclick="checkCacheStatus()">
                üìä Check Status
            </button>
        </div>
    </div>

    <div class="test-section">
        <div class="section-title">
            üîå Connection Simulation
        </div>
        <div class="section-description">
            Simulate different network conditions to test offline capabilities.
        </div>
        
        <div class="connection-controls">
            <div class="connection-btn active" onclick="setConnectionState('online')">
                üì∂ Online
            </div>
            <div class="connection-btn" onclick="setConnectionState('slow')">
                üêå Slow 3G
            </div>
            <div class="connection-btn" onclick="setConnectionState('offline')">
                üìµ Offline
            </div>
            <div class="connection-btn" onclick="setConnectionState('flaky')">
                ‚ö° Flaky
            </div>
        </div>
        
        <div class="action-buttons">
            <button class="action-btn" onclick="testOfflineLoad()">
                üß™ Test Offline Load
            </button>
            <button class="action-btn" onclick="testDataSync()">
                üîÑ Test Data Sync
            </button>
        </div>
    </div>

    <div class="test-section">
        <div class="section-title">
            üè™ Local Storage Test
        </div>
        <div class="section-description">
            Test local storage persistence for workout data and user preferences.
        </div>
        
        <div class="storage-test">
            <input type="text" class="storage-input" id="storageKey" placeholder="Storage key (e.g., workoutData)">
            <input type="text" class="storage-input" id="storageValue" placeholder="Storage value (JSON or text)">
            
            <div class="action-buttons">
                <button class="action-btn" onclick="saveToStorage()">
                    üíæ Save
                </button>
                <button class="action-btn" onclick="loadFromStorage()">
                    üìñ Load
                </button>
                <button class="action-btn secondary" onclick="clearStorage()">
                    üóëÔ∏è Clear
                </button>
            </div>
            
            <div class="storage-display" id="storageDisplay">
                Storage contents will appear here...
            </div>
        </div>
    </div>

    <div class="test-section">
        <div class="section-title">
            üì± PWA Manifest Validation
        </div>
        <div class="section-description">
            Verify PWA manifest requirements for installation and home screen support.
        </div>
        
        <div id="manifestChecks">
            <div class="manifest-check">
                <span class="check-icon">‚è≥</span>
                <span class="check-description">Loading manifest validation...</span>
                <span class="check-value"></span>
            </div>
        </div>
        
        <div class="install-prompt" id="installPrompt">
            <h3>üì± Install 6Week Shred</h3>
            <p>Add this app to your home screen for quick access and offline use!</p>
            <div class="action-buttons" style="justify-content: center;">
                <button class="action-btn" onclick="installPWA()">
                    üì≤ Install App
                </button>
                <button class="action-btn secondary" onclick="dismissInstall()">
                    ‚ùå Not Now
                </button>
            </div>
        </div>
        
        <div class="action-buttons">
            <button class="action-btn" onclick="validateManifest()">
                ‚úÖ Validate Manifest
            </button>
            <button class="action-btn secondary" onclick="simulateInstall()">
                üì± Simulate Install
            </button>
        </div>
    </div>

    <div class="test-section">
        <div class="section-title">
            üìä Test Results
        </div>
        <div class="test-results" id="testResults">
            <div class="result-info">üöÄ Offline PWA test suite initialized</div>
            <div class="result-info">üåê Checking network connectivity and service worker status...</div>
        </div>
    </div>

    <script>
        class OfflinePWATest {
            constructor() {
                this.swRegistration = null;
                this.installPromptEvent = null;
                this.connectionState = 'online';
                this.criticalResources = [
                    '/',
                    '/index.html',
                    '/manifest.json',
                    '/styles/app.css',
                    '/styles/mobile.css',
                    '/scripts/app.js',
                    '/scripts/data-manager.js'
                ];
                
                this.initializeTests();
                this.setupEventListeners();
                this.monitorNetwork();
            }

            initializeTests() {
                this.log('Initializing offline PWA tests...', 'info');
                this.checkServiceWorkerSupport();
                this.checkStorageSupport();
                this.detectInstallPrompt();
                this.validateManifest();
            }

            setupEventListeners() {
                // Service worker events
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.addEventListener('message', (event) => {
                        this.log(`SW Message: ${event.data.type}`, 'info');
                    });
                }

                // PWA install events
                window.addEventListener('beforeinstallprompt', (e) => {
                    e.preventDefault();
                    this.installPromptEvent = e;
                    document.getElementById('installPrompt').classList.add('show');
                    this.log('PWA install prompt available', 'pass');
                });

                window.addEventListener('appinstalled', () => {
                    this.log('PWA successfully installed!', 'pass');
                    document.getElementById('installPrompt').classList.remove('show');
                });

                // Network events
                window.addEventListener('online', () => {
                    this.updateNetworkStatus(true);
                    this.log('Connection restored', 'pass');
                });

                window.addEventListener('offline', () => {
                    this.updateNetworkStatus(false);
                    this.log('Connection lost - testing offline mode', 'warning');
                });
            }

            monitorNetwork() {
                this.updateNetworkStatus(navigator.onLine);
                
                // Periodic connection check
                setInterval(() => {
                    this.checkConnection();
                }, 5000);
            }

            updateNetworkStatus(isOnline) {
                const status = document.getElementById('networkStatus');
                const dot = document.getElementById('networkDot');
                const text = document.getElementById('networkText');
                const details = document.getElementById('networkDetails');
                
                if (isOnline) {
                    status.className = 'network-status online';
                    dot.className = 'network-dot';
                    text.textContent = 'Online';
                    details.textContent = 'Connected to internet';
                } else {
                    status.className = 'network-status offline';
                    dot.className = 'network-dot offline';
                    text.textContent = 'Offline';
                    details.textContent = 'Working offline';
                }
            }

            async checkConnection() {
                try {
                    const response = await fetch('/manifest.json', { 
                        method: 'HEAD',
                        cache: 'no-cache' 
                    });
                    
                    if (response.ok) {
                        const details = document.getElementById('networkDetails');
                        details.textContent = `Connected (${response.status})`;
                    }
                } catch (error) {
                    // Connection failed, but don't update status as it might be a flaky connection
                }
            }

            checkServiceWorkerSupport() {
                if ('serviceWorker' in navigator) {
                    this.log('‚úÖ Service Worker API supported', 'pass');
                    this.registerServiceWorker();
                } else {
                    this.log('‚ùå Service Worker API not supported', 'fail');
                    this.updateSWStatus('swRegistration', 'error', 'Not Supported');
                }
            }

            async registerServiceWorker() {
                if (!('serviceWorker' in navigator)) {
                    this.log('Service Worker not supported', 'fail');
                    return;
                }

                try {
                    this.updateSWStatus('swRegistration', 'pending', 'Registering...');
                    
                    const registration = await navigator.serviceWorker.register('/service-worker.js', {
                        scope: '/'
                    });
                    
                    this.swRegistration = registration;
                    this.updateSWStatus('swRegistration', 'online', 'Registered');
                    this.log('‚úÖ Service Worker registered successfully', 'pass');
                    
                    // Monitor installation
                    if (registration.installing) {
                        this.monitorSWState(registration.installing, 'installing');
                    } else if (registration.waiting) {
                        this.updateSWStatus('swInstallation', 'online', 'Installed');
                        this.updateSWStatus('swUpdate', 'warning', 'Update available');
                    } else if (registration.active) {
                        this.updateSWStatus('swInstallation', 'online', 'Installed');
                        this.updateSWStatus('swActivation', 'online', 'Active');
                    }
                    
                    // Check for updates
                    registration.addEventListener('updatefound', () => {
                        this.log('Service Worker update found', 'info');
                        this.monitorSWState(registration.installing, 'updating');
                    });
                    
                } catch (error) {
                    this.updateSWStatus('swRegistration', 'error', 'Failed');
                    this.log(`‚ùå Service Worker registration failed: ${error.message}`, 'fail');
                }
            }

            monitorSWState(worker, phase) {
                worker.addEventListener('statechange', () => {
                    this.log(`SW ${phase}: ${worker.state}`, 'info');
                    
                    switch (worker.state) {
                        case 'installing':
                            this.updateSWStatus('swInstallation', 'pending', 'Installing...');
                            break;
                        case 'installed':
                            this.updateSWStatus('swInstallation', 'online', 'Installed');
                            if (phase === 'updating') {
                                this.updateSWStatus('swUpdate', 'warning', 'Update ready');
                            }
                            break;
                        case 'activating':
                            this.updateSWStatus('swActivation', 'pending', 'Activating...');
                            break;
                        case 'activated':
                            this.updateSWStatus('swActivation', 'online', 'Active');
                            this.log('‚úÖ Service Worker activated', 'pass');
                            if (phase === 'updating') {
                                this.updateSWStatus('swUpdate', 'online', 'Updated');
                            }
                            break;
                        case 'redundant':
                            this.log('Service Worker became redundant', 'warning');
                            break;
                    }
                });
            }

            updateSWStatus(elementId, status, message) {
                const element = document.getElementById(elementId);
                const statusElement = element.querySelector('.status-value');
                
                element.className = `status-card ${status}`;
                statusElement.textContent = message;
            }

            async unregisterServiceWorker() {
                if (!this.swRegistration) {
                    this.log('No service worker to unregister', 'warning');
                    return;
                }

                try {
                    await this.swRegistration.unregister();
                    this.log('‚úÖ Service Worker unregistered', 'pass');
                    this.updateSWStatus('swRegistration', 'offline', 'Unregistered');
                    this.updateSWStatus('swInstallation', 'offline', 'Removed');
                    this.updateSWStatus('swActivation', 'offline', 'Inactive');
                } catch (error) {
                    this.log(`‚ùå Failed to unregister SW: ${error.message}`, 'fail');
                }
            }

            async checkForUpdates() {
                if (!this.swRegistration) {
                    this.log('No service worker registered', 'warning');
                    return;
                }

                try {
                    await this.swRegistration.update();
                    this.log('Checked for service worker updates', 'info');
                } catch (error) {
                    this.log(`Update check failed: ${error.message}`, 'fail');
                }
            }

            async checkCacheStatus() {
                if (!('caches' in window)) {
                    this.log('‚ùå Cache API not supported', 'fail');
                    return;
                }

                try {
                    const cacheNames = await caches.keys();
                    this.log(`Found ${cacheNames.length} cache(s)`, 'info');
                    
                    const cacheList = document.getElementById('cacheList');
                    cacheList.innerHTML = '';

                    if (cacheNames.length === 0) {
                        cacheList.innerHTML = '<li class="cache-item failed"><span>No caches found</span><span class="cache-status">Empty</span></li>';
                        return;
                    }

                    for (const cacheName of cacheNames) {
                        const cache = await caches.open(cacheName);
                        const requests = await cache.keys();
                        
                        const li = document.createElement('li');
                        li.className = 'cache-item cached';
                        li.innerHTML = `
                            <span>${cacheName} (${requests.length} resources)</span>
                            <span class="cache-status">Cached</span>
                        `;
                        cacheList.appendChild(li);
                        
                        // Check critical resources
                        for (const resource of this.criticalResources) {
                            const resourceLi = document.createElement('li');
                            const cachedResponse = await cache.match(resource);
                            
                            if (cachedResponse) {
                                resourceLi.className = 'cache-item cached';
                                resourceLi.innerHTML = `
                                    <span style="padding-left: 20px;">${resource}</span>
                                    <span class="cache-status">‚úì Cached</span>
                                `;
                            } else {
                                resourceLi.className = 'cache-item failed';
                                resourceLi.innerHTML = `
                                    <span style="padding-left: 20px;">${resource}</span>
                                    <span class="cache-status">‚úó Missing</span>
                                `;
                            }
                            cacheList.appendChild(resourceLi);
                        }
                    }
                    
                } catch (error) {
                    this.log(`Cache check failed: ${error.message}`, 'fail');
                }
            }

            async populateCache() {
                if (!('caches' in window)) {
                    this.log('‚ùå Cache API not supported', 'fail');
                    return;
                }

                try {
                    const cache = await caches.open('workout-app-v1');
                    this.log('Caching critical resources...', 'info');
                    
                    let successCount = 0;
                    for (const resource of this.criticalResources) {
                        try {
                            await cache.add(resource);
                            successCount++;
                            this.log(`‚úì Cached: ${resource}`, 'pass');
                        } catch (error) {
                            this.log(`‚úó Failed to cache: ${resource}`, 'fail');
                        }
                    }
                    
                    this.log(`‚úÖ Cached ${successCount}/${this.criticalResources.length} resources`, 'pass');
                    this.checkCacheStatus();
                    
                } catch (error) {
                    this.log(`‚ùå Cache population failed: ${error.message}`, 'fail');
                }
            }

            async clearCache() {
                if (!('caches' in window)) {
                    this.log('‚ùå Cache API not supported', 'fail');
                    return;
                }

                try {
                    const cacheNames = await caches.keys();
                    const deletePromises = cacheNames.map(name => caches.delete(name));
                    await Promise.all(deletePromises);
                    
                    this.log(`‚úÖ Cleared ${cacheNames.length} cache(s)`, 'pass');
                    this.checkCacheStatus();
                    
                } catch (error) {
                    this.log(`‚ùå Cache clearing failed: ${error.message}`, 'fail');
                }
            }

            checkStorageSupport() {
                try {
                    localStorage.setItem('test', 'test');
                    localStorage.removeItem('test');
                    this.log('‚úÖ Local Storage supported', 'pass');
                    
                    if ('indexedDB' in window) {
                        this.log('‚úÖ IndexedDB supported', 'pass');
                    } else {
                        this.log('‚ö†Ô∏è IndexedDB not supported', 'warning');
                    }
                    
                } catch (error) {
                    this.log('‚ùå Local Storage not supported', 'fail');
                }
            }

            saveToStorage() {
                const key = document.getElementById('storageKey').value;
                const value = document.getElementById('storageValue').value;
                
                if (!key || !value) {
                    this.log('Please enter both key and value', 'warning');
                    return;
                }

                try {
                    localStorage.setItem(key, value);
                    this.log(`‚úÖ Saved: ${key}`, 'pass');
                    this.displayStorageContents();
                } catch (error) {
                    this.log(`‚ùå Save failed: ${error.message}`, 'fail');
                }
            }

            loadFromStorage() {
                const key = document.getElementById('storageKey').value;
                
                if (!key) {
                    this.log('Please enter a key to load', 'warning');
                    return;
                }

                try {
                    const value = localStorage.getItem(key);
                    if (value !== null) {
                        document.getElementById('storageValue').value = value;
                        this.log(`‚úÖ Loaded: ${key}`, 'pass');
                    } else {
                        this.log(`Key not found: ${key}`, 'warning');
                    }
                } catch (error) {
                    this.log(`‚ùå Load failed: ${error.message}`, 'fail');
                }
            }

            clearStorage() {
                const key = document.getElementById('storageKey').value;
                
                if (key) {
                    localStorage.removeItem(key);
                    this.log(`‚úÖ Removed: ${key}`, 'pass');
                } else {
                    localStorage.clear();
                    this.log('‚úÖ Cleared all local storage', 'pass');
                }
                
                this.displayStorageContents();
                document.getElementById('storageValue').value = '';
            }

            displayStorageContents() {
                const display = document.getElementById('storageDisplay');
                const contents = {};
                
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    contents[key] = localStorage.getItem(key);
                }
                
                display.textContent = JSON.stringify(contents, null, 2);
            }

            async validateManifest() {
                try {
                    const response = await fetch('/manifest.json');
                    const manifest = await response.json();
                    
                    const checks = [
                        {
                            test: manifest.name && manifest.name.length > 0,
                            description: 'App name is defined',
                            value: manifest.name || 'Missing'
                        },
                        {
                            test: manifest.short_name && manifest.short_name.length > 0,
                            description: 'Short name is defined',
                            value: manifest.short_name || 'Missing'
                        },
                        {
                            test: manifest.start_url !== undefined,
                            description: 'Start URL is defined',
                            value: manifest.start_url || 'Missing'
                        },
                        {
                            test: manifest.display && ['standalone', 'fullscreen', 'minimal-ui'].includes(manifest.display),
                            description: 'Display mode is app-like',
                            value: manifest.display || 'browser'
                        },
                        {
                            test: manifest.icons && manifest.icons.length >= 2,
                            description: 'Multiple icon sizes provided',
                            value: manifest.icons ? `${manifest.icons.length} icons` : '0 icons'
                        },
                        {
                            test: manifest.theme_color !== undefined,
                            description: 'Theme color is defined',
                            value: manifest.theme_color || 'Missing'
                        },
                        {
                            test: manifest.background_color !== undefined,
                            description: 'Background color is defined',
                            value: manifest.background_color || 'Missing'
                        }
                    ];
                    
                    this.displayManifestChecks(checks);
                    
                    const passCount = checks.filter(check => check.test).length;
                    this.log(`Manifest validation: ${passCount}/${checks.length} checks passed`, 
                             passCount === checks.length ? 'pass' : 'warning');
                    
                } catch (error) {
                    this.log(`‚ùå Manifest validation failed: ${error.message}`, 'fail');
                    this.displayManifestChecks([{
                        test: false,
                        description: 'Manifest file accessibility',
                        value: 'Failed to load'
                    }]);
                }
            }

            displayManifestChecks(checks) {
                const container = document.getElementById('manifestChecks');
                container.innerHTML = '';
                
                checks.forEach(check => {
                    const div = document.createElement('div');
                    div.className = 'manifest-check';
                    
                    const icon = check.test ? '‚úÖ' : '‚ùå';
                    const iconClass = check.test ? 'pass' : 'fail';
                    
                    div.innerHTML = `
                        <span class="check-icon ${iconClass}">${icon}</span>
                        <span class="check-description">${check.description}</span>
                        <span class="check-value">${check.value}</span>
                    `;
                    
                    container.appendChild(div);
                });
            }

            detectInstallPrompt() {
                // Check if already installed
                if (window.matchMedia('(display-mode: standalone)').matches) {
                    this.log('‚úÖ App is running in standalone mode', 'pass');
                    document.getElementById('installPrompt').style.display = 'none';
                } else {
                    this.log('App is running in browser', 'info');
                }
            }

            installPWA() {
                if (this.installPromptEvent) {
                    this.installPromptEvent.prompt();
                    this.installPromptEvent.userChoice.then((choiceResult) => {
                        if (choiceResult.outcome === 'accepted') {
                            this.log('‚úÖ User accepted PWA install', 'pass');
                        } else {
                            this.log('User dismissed PWA install', 'info');
                        }
                        this.installPromptEvent = null;
                    });
                } else {
                    this.log('‚ö†Ô∏è Install prompt not available', 'warning');
                }
            }

            dismissInstall() {
                document.getElementById('installPrompt').classList.remove('show');
                this.log('Install prompt dismissed', 'info');
            }

            simulateInstall() {
                this.log('Simulating PWA installation process...', 'info');
                setTimeout(() => {
                    this.log('‚úÖ PWA installation simulation complete', 'pass');
                }, 1000);
            }

            setConnectionState(state) {
                // Update UI
                document.querySelectorAll('.connection-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                event.target.classList.add('active');
                
                this.connectionState = state;
                this.log(`Connection state set to: ${state}`, 'info');
                
                // Simulate different connection states
                switch (state) {
                    case 'offline':
                        this.updateNetworkStatus(false);
                        break;
                    case 'slow':
                        this.updateNetworkStatus(true);
                        this.log('Simulating slow 3G connection', 'warning');
                        break;
                    case 'flaky':
                        this.simulateFlakyConnection();
                        break;
                    default:
                        this.updateNetworkStatus(true);
                }
            }

            simulateFlakyConnection() {
                this.log('Simulating flaky connection...', 'warning');
                let isOnline = true;
                
                const flaky = setInterval(() => {
                    isOnline = !isOnline;
                    this.updateNetworkStatus(isOnline);
                    this.log(`Connection ${isOnline ? 'restored' : 'lost'}`, isOnline ? 'pass' : 'warning');
                }, 2000);
                
                // Stop after 10 seconds
                setTimeout(() => {
                    clearInterval(flaky);
                    this.updateNetworkStatus(true);
                    this.log('Flaky connection simulation ended', 'info');
                }, 10000);
            }

            async testOfflineLoad() {
                this.log('Testing offline page load...', 'info');
                
                try {
                    // Try to load a cached resource
                    const response = await fetch('/', { cache: 'force-cache' });
                    if (response.ok) {
                        this.log('‚úÖ Offline page load successful', 'pass');
                    } else {
                        this.log('‚ùå Offline page load failed', 'fail');
                    }
                } catch (error) {
                    this.log(`‚ùå Offline load error: ${error.message}`, 'fail');
                }
            }

            async testDataSync() {
                this.log('Testing data synchronization...', 'info');
                
                // Simulate saving data while offline
                const testData = {
                    timestamp: Date.now(),
                    workout: 'Test workout data',
                    offline: !navigator.onLine
                };
                
                try {
                    localStorage.setItem('sync-test', JSON.stringify(testData));
                    this.log('‚úÖ Data saved locally', 'pass');
                    
                    if (navigator.onLine) {
                        // Simulate sync when online
                        setTimeout(() => {
                            this.log('‚úÖ Data synchronized with server (simulated)', 'pass');
                        }, 1000);
                    } else {
                        this.log('üìã Data queued for sync when online', 'info');
                    }
                    
                } catch (error) {
                    this.log(`‚ùå Data sync test failed: ${error.message}`, 'fail');
                }
            }

            log(message, type = 'info') {
                const results = document.getElementById('testResults');
                const className = {
                    'pass': 'result-pass',
                    'fail': 'result-fail',
                    'warning': 'result-warning',
                    'info': 'result-info'
                }[type] || 'result-info';
                
                const div = document.createElement('div');
                div.className = className;
                div.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                results.appendChild(div);
                results.scrollTop = results.scrollHeight;
            }
        }

        // Global functions for buttons
        let offlineTest;

        function registerServiceWorker() { offlineTest.registerServiceWorker(); }
        function unregisterServiceWorker() { offlineTest.unregisterServiceWorker(); }
        function checkForUpdates() { offlineTest.checkForUpdates(); }
        function populateCache() { offlineTest.populateCache(); }
        function clearCache() { offlineTest.clearCache(); }
        function checkCacheStatus() { offlineTest.checkCacheStatus(); }
        function saveToStorage() { offlineTest.saveToStorage(); }
        function loadFromStorage() { offlineTest.loadFromStorage(); }
        function clearStorage() { offlineTest.clearStorage(); }
        function validateManifest() { offlineTest.validateManifest(); }
        function installPWA() { offlineTest.installPWA(); }
        function dismissInstall() { offlineTest.dismissInstall(); }
        function simulateInstall() { offlineTest.simulateInstall(); }
        function setConnectionState(state) { offlineTest.setConnectionState(state); }
        function testOfflineLoad() { offlineTest.testOfflineLoad(); }
        function testDataSync() { offlineTest.testDataSync(); }

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            offlineTest = new OfflinePWATest();
            
            // Initial storage display
            setTimeout(() => {
                offlineTest.displayStorageContents();
                offlineTest.checkCacheStatus();
            }, 500);
        });
    </script>
</body>
</html>